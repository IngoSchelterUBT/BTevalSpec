import sys

#Module for output of ERRORS and WARNINGS

#------------------------------------------------------------------------------#
# Error handler
# Input: code (Error code), msg (Error Message)
#------------------------------------------------------------------------------#
def err(code,msg,cmd=""):
    print('')
    print("ERROR: " + msg)
    print('')
    usage(cmd=cmd)
    sys.exit(code)

#------------------------------------------------------------------------------#
# Warning
# Input: msg (Error Message)
#------------------------------------------------------------------------------#
def warn(msg):
    print('')
    print('WARNING: ' + msg)
    print('')

#------------------------------------------------------------------------------#
# Print usage information
#------------------------------------------------------------------------------#
def usage(cmd=""):
    print("--------------------")
    print("")
    print("Usage:")
    print("")
    print("  ./BTevalSpec.py [-h |--help] [{-v |--verbose=}<dbg>] [{-f |--file=}<fname.yaml>] [<cmd-opt>] cmd arg")
    print("")
    print("  General options")
    print("     -h, -v, and -f are referenced as general options (<gen-opt>) below")
    print("     -v (verbose) has several levels: 0 produces minimal output, 1 is usually useful, 2 is for debugging.")
    print("     -f <file>    specify a different input yaml file (default: eval.yaml)")
    print("")
    print("  Help")
    print("    -h all   Prints all help messages")
    print("    -h gen   Prints general information and workflow")
    print("    -h yaml  Prints the eval.yaml-specific help message.")
    print("    -h cmd   Prints an one-line overview over all commands")
    print("    -h <cmd> Prints the <cmd>-specific help message.")
    print("")
    print("  Reference:")
    print("    The algorithms are explained in")
    print("      I. Schelter, S. Kuemmel,         JCTC 14, 1910-1927 (2018)")
    print("      I. Schelter, S. Kuemmel, et al., unpub. (2025) (will be updated when the paper is published)")
    print("")
    print("  Testing / Examples:")
    print("    Examples/Tests are provided in the 'testTemplates' directory. Copy this directory an run the included tests.")
    if cmd in ["all","gen"]:
        print("")
        print(" ----------")
        print("  Workflow")
        print("    1) Copy/Link all required files into the evaluation directory (dipole moments, external-field profile, n(r,w_k), BTevalSpec.py)")
        print("")
        print("    2) Create a new input-file template")
        print("       ./BTevalSpec.py new")
        print("")
        print("    3) Edit the newly created eval.yaml")
        print("       Add dipole-moment files and external-field profile (if required)")
        print("       Adjust the fit range (if you don't know one yet, see below)")
        print("")
        print("    Note: After each call to BTevalSpec.py in the following, the eval.yaml file is updated and automatically used for the next call to BTevalSpec.py")
        print("          This way, one can manually run the script step-by-step and intervene whenever it is necessary.")
        print("          It is also possible to manually adjust the eval.yaml file.")
        print("")
        print("    4) Add & fit new excitations one after the other (repeat the following steps)")
        print("       0a) [optional] If you don't know how the spectrum looks like, first compute the Fourier- or Pade spectra initially and inspect them")
        print("          ./BTevalSpec.py {ft|pade}")
        print("       0b) [optional] If you want to make an initial guess without fitting, call")
        print("          ./BTevalSpec.py [--guess={ft|pade}] guess")
        print("       a) Run one iteration with the fit command:")
        print("          ./BTevalSpec.py --skip --niter=1 [--nsig=<val>] fit")
        print("             --skip skips the first fit of the input excitations")
        print("             --niter=1 makes one iteration consisting of (i) guess a set of new excitations (ii) fit new excitations (iii) fit all excitations together (iv) compute error and significance measures")
        print("             --nsig=<val> Adjust the threshold that determines if the script accepts a peak as an excitation. A larger value accepts less peaks.")
        print("          This automatically evaluates the current difference between computed spectrum and the fit, finds new excitations at peak positions, and fits the excitations.")
        print("          Note: This command automatically computes the Fourier and Pade spectra if not already done. Later calls will just read the latter.")
        print("       b) [optional] backup the updated eval.yaml so you can return to this stage later if necessary")
        print("       c) check significance measures (in eval.yaml or comprehensively in excit_1.dat) and decide to")
        print("          - stop the fit")
        print("          - adjust the excitations manually")
        print("          - do another iteration -> 4a)")
        print("          - plot spectra/fit/...")
        print("             ./BTevalSpec.py plot")
        print("          Note: A low significance can indicate that an excitation is erroneous. However, it can also show that there are still excitations missing in the vicinity.")
        print("")
        print("    5) Evaluate transition densities (requires the DENSFT section in eval.yaml with as many n(r,w_k) as there are excitations)")
        print("       ./BTevalSpec.py decouple")
    if cmd in ["all","cmd"]:
        print("")
        print(" ----------")
        print(" Command overview:")
        print("")
        print("  yaml     - [only with -h option] Print eval.yaml-specific help message")
        print("  cmd      - [only with -h option] Print eval.yaml-specific help message")
        print("  new      - create a new configuration file")
        print("  ft       - compute Fourier spectrum")
        print("  pade     - compute Pade    spectrum")
        print("  guess    - make an initial guess for the fit")
        print("  fit      - fit and add new excitations")
        print("  plot     - Plot certain spectra and fits")
        print("  rm       - remove an excitation")
        print("  add      - add    an excitation")
        print("  fix      - fix    an excitation (don't change its energy/dipole parameters during the fit)")
        print("  release  - opposite of fix")
        print("  reset    - reset the excitation's energy-interval that restricts the fit")
        print("  decouple - compute transition densities from Fourier-transformed densities (after the fit is complete)")
        print("")
        print("    Note: After each call to BTevalSpec.py in the following, the eval.yaml file is updated and automatically used for the next call to BTevalSpec.py")
        print("          This way, one can manually run the script step-by-step and intervene whenever it is necessary.")
        print("          It is also possible to manually adjust the eval.yaml file.")
    if cmd in ["all","yaml"]:
        print("")
        print(" ----------")
        print("")
        print("    Note: Most fields in the yaml file are filled automatically.")
        print("          After creating a new eval.yaml, you only need to specify/adjust")
        print("           - The file paths (dipole moments and laser profile if required)")
        print("           - The fit range (if you run a fit)")
        print("           - wmax (PADE) if you want a Pade spectrum")
        print("")
        print("    Note: After each call to BTevalSpec.py in the following, the eval.yaml file is updated and automatically used for the next call to BTevalSpec.py")
        print("          This way, one can manually run the script step-by-step and intervene whenever it is necessary.")
        print("          It is also possible to manually adjust the eval.yaml file.")
        print("")
        print(" eval.yaml file format:")
        print("")
        print("DESCRIPTION:                        # Description of evaluation")
        print("DIPOLE:                             # List of dipole moment files")
        print("                                    #   Outer list: dipole moments from different calculations (different external-field polarizations)")
        print("                                    #   Inner list: dipole moments from different spatial areas from the same calculation")
        print("- [dipole_calc1_area1.dat, dipole_calc1_area2.dat]")
        print("- [dipole_calc2_area1.dat, ...]")
        print("  #...")
        print("DENSFT:                             # Specify Fourier-transformed densities n(r,w_k) and w_k for transition-density calculation")
        print("  densft:                           #   List of n(r,w_k) (as many as excitations at w_k close to the excitation energies)")
        print("  - densft01.compact                #     Either as complex-valued BTcompact files (requires BTDFT-modules)")
        print("  - densft02.compact")
        print("  #OR")
        print("  - [densft01r.cube,densft01i.cube] #     or lists of [real,imag] Gaussian cube files")
        print("  - [densft02r.cube,densft02i.cube]")
        print("  #OR")
        print("  - densft01i.cube                  #     or imag-valued Gaussian cube files with the --imag to the decouple command option")
        print("  - densft02i.cube")
        print("  #...")
        print("  densen:                           #   the list of w_k (same order)")
        print("  - 0.131990")
        print("  - 0.134330")
        print("  #...")
        print("  jcalc: 0                          #   the calculation which created the n(r,w_k) (in case dipole-moment data came from different calculations). Starts with '0' (default)")
        print("OPT:                                # Options & values for")
        print("  FT:                               #   Fourier transform")
        print("    calc: false                     #     true: compute, false: read from files")
        print("    minpw: 17                       #     zero padding up to (at least) 2^<minpw>")
        print("    window: 0.0                     #     Kaiser-Bessel Window parameter (leave 0 for fit)")
        print("    smooth: 0.0                     #     Damping rate (leave 0 for fit)")
        print("    rmDC: false                     #     Subtract omega=0 component from the dipole moment (leave false)")
        print("  Pade:                             #   Pade approximation")
        print("    calc: false                     #     true: compute, false: read from files")
        print("    wmax: 0.5                       #     Upper energy bound [Ry] for Pade approximation (increase to approximate a larger part of the spectrum)")
        print("    dw: 1e-05                       #     Energy sampling (distance between omega sampling points)")
        print("    smooth: 0.0022278747967549423   #     Artificial decay rate used for Pade approximation (decrease to get sharper lines)")
        print("    thin: 0                         #     Use every 2^<thin>'s time step to evaluate the Pade spectrum (artificially increases the time-step size for comput. efficiency; leave zero)")
        print("  Fit:                              #   Fit")
        print("    range:                          #     Range of spectrum which should be fitted in Ry")
        print("    - 0.10")
        print("    - 0.28")
        print("    imagonly: false                 #     [in, optional] Set true if only the imaginary part shall be used (automatically true for a boost)")
        print("    fiterr: 0.01029415706259413     #     [out         ] Comprehensive fit error")
        print("    fitphase: false                 #     [in, optional] If true, the phase is used as a fit parameter (otherwise, it determined from the external-field profile)")
        print("EXT:                                # External-field")
        print("  profile: laser_profile.dat        #   [in, if laser excitation] Laser-profile file")
        print("  invertPhase: false                #   [in, optional           ] If true, multiplies the laser profile with '-1' (e.g., for BTDFT until v3.6.0)")
        print("SPEC:                               # Spectral information (fit)")
        print("- name: S1                          #   Excitation name (defaults to S<number>) but can be changed")
        print("  fix: false                        #   True, if the excitation is fixed (can be set manually for the next run)")
        print("  energy: 0.13198769111844885       #   Current value of the excitation's energy")
        print("  phase: 0.0                        #   Current value of the excitation's phase")
        print("  dipoles:                          #   Area-contributions to the transition dipole (consistent over calculations)")
        print("  - - 0.0014764204066536474")
        print("    - 0.3074363126526123")
        print("    - 0.3473751252687603")
        print("  ampl:                             #   Calculation- and Area-contributions to the vector amplitudes (different for different calculations)")
        print("  - - - -1.977874864015696e-06")
        print("      - -0.0004118546129144092")
        print("      - -0.000465358325824443")
        print("  dipole:                           #   Global transition dipole")
        print("  - 0.0014764204066536474")
        print("  - 0.3074363126526123")
        print("  - 0.3473751252687603")
        print("  strength: 0.004733710908363272    #   Oscillator strength")
        print("                                    #   Significance measures:")
        print("  signifFit: 0.0                    #   Only computed with --signif option to the 'fit' command")
        print("  signifErr: 0.9334766695559699")
        print("  signifAng: 0.9037784539834844")
        print("  signifExc: 0.0                    #   Only computed with --signif option to the 'fit' command")
        print("  signifRng: 0.9999997972734961")
        print("  signifPha: 1.0")
        print("    #...                            #   There are further quantities such as error estimates etc. for the single quantities")
        print("- name: S2                          # Further excitations")
        print("  #...")
    if cmd in ["all","new"]:
        print("")
        print(" ----------")
        print(" Create a new configuration file")
        print("")
        print("  ./BTevalSpec.py [<gen-opt>] new")
        print("")
        print("    Generates a new yaml file (default: eval.yaml).")
        print("    After creation, the user must add dipole-moment files and potentially a laser-profile file")
        print("    Moreover, the fit range [Ry] can be adjusted.")
        print("")
        print("  Example (eval.yaml):")
        print("")
        print("...")
        print("DIPOLE:                             # List of dipole moment files. Different calculations are only allowed to differ in the boost/laser polarization")
        print("  - [dipole_calc01_area01.dat, dipole_calc01_area02.dat]")
        print("  - [dipole_calc02_area01.dat, dipole_calc02_area02.dat]")
        print("EXT:")
        print("  profile: laser_profile.dat        # Profile of excitation")
        print("  invertPhase: false                # Before BTDFT v3.6.0, the laser profile missed a factor '-1'. InvertPhase==True compensates this error.")
        print("OPT:")
        print("  ...")
        print("  Fit:")
        print("    range:                          # Range of spectrum which should be fitted in Ry")
        print("    - 0.10                          # If you don't know a proper fit range yet, you separately compute the FT/Pade spectrum and inspect it visally.")
        print("    - 0.40")
        print("...")
        print("")
    if cmd in ["all","ft"]:
        print("")
        print(" ----------")
        print(" Fourier transform")
        print("")
        print("  ./BTevalSpec.py [<gen-opt>] [--minpw=<pw>] [--smooth=<smooth>] [--window=<win>] [--rmDC] ft")
        print("")
        print("    Fourier-transforms the induced dipole moment, writes them into files, and updates eval.yaml. ")
        print("")
        print("    <gen-opt>         General options")
        print("    --minpw=<pw>      Pad the induced dipole moment with zeros up to 2^<pw> to increase the frequency-space sampling rate (without changing the FT itself) (default: 17)")
        print("    --smooth=<smooth> Multiply the induced dipole moment with a decaying exponential function e^(-<smooth>*t) for smoother lines (default: 0)")
        print("    --window=<win>    Applies a Kaiser-Bessel window with parameter <win> to the induced dipole moment (default: 0)")
        print("    --rmDC            Remove the DC (omega=0) component of the induced dipole moment d(t) by subtracting int d(t) dt. This is usually not recommended.")
        print("")
        print("  Attention: A smoothed or windowed signal cannot be used for subsequent fitting but is only intended for visual inspection.")
        print("")
        print("  Note: The Fourier transform is automatically computed if you use the 'fit' command.")
        print("        The 'ft' command is useful, if you only want the Fourier spectrum in the first place without any fitting.")
        print("")
        print("  Note: If the Fourier transform was computed previously, it is not computed again but read from the previously generated files")
        print("        This is automatically enforced by setting 'FT: {calc: false}' in the eval.yaml file after computing the Fourier transform once.")
        print("        If, for some reason (e.g. you deleted the FT files), you want to compute the Fourier transform again, you have to set this option to 'true' again in eval.yaml of use the 'ft' command manually.")
    if cmd in ["all","pade"]:
        print("")
        print(" ----------")
        print(" Pade approx")
        print("")
        print("  ./BTevalSpec.py [<gen-opt>] [--wmax=<wmax>] [--dw=<dw>] [--smooth=<smooth>] [--thin=<thin>] pade")
        print("")
        print("    Computes the Pade spectrum of the induced dipole moment, writes them into files, and updates eval.yaml.")
        print("")
        print("    <gen-opt>         General options")
        print("    --wmax=<wmax>     Upper omega boundary (in Ry units) (default: 0.5)")
        print("    --smooth=<smooth> Multiply the induced dipole moment with a decaying exponential function e^(-<smooth>*t) for smoother lines. This is alway applied for computing the Pade spectrum.")
        print("                      Smaller <smooth> values (=decay rates) result in sharper lines (but still smooth in contrast to the Fourier spectrum). Too small values, however, can produce artifacts. (default: ln(100)/<propagation time>)")
        print("    --dw=<dw>         Frequency-space sampling step size (default: 1E-5)")
        print("    --thin=<thin>     Thins out the dipole-moment samples using only every <thin>'s value to lower the computation burden and file size (default: 0)")
        print("")
        print("  Note: The Pade spectrum is automatically computed if you use the 'fit' command.")
        print("        The 'pade' command is useful, if you only want the Pade spectrum in the first place without any fitting.")
        print("")
        print("  Note: If the Pade spectrum was computed previously, it is not computed again but read from the previously generated files")
        print("        This is automatically enforced by setting 'Pade: {calc: false}' in the eval.yaml file after computing the Pade spectrum once.")
        print("        If, for some reason (e.g. you deleted the Pade files), you want to compute the Pade spectrum again, you have to set this option to 'true' again in eval.yaml of use the 'pade' command manually.")
    if cmd in ["all","guess"]:
        print("")
        print(" ----------")
        print(" Make a new guess based on the Fourier (default) or Pade spectrum)")
        print("")
        print("  ./BTevalSpec.py [<gen-opt>] [--guess=pade [<pade opt>] [--thres=<thres>]| --guess=ft [<ft opt>] [--nsig=<nsig>]] [--range=<lb,rb>] [--imag] guess")
        print("")
        print("    Creates an initial guess for the first batch of spectral lines without fitting and updates eval.yaml.")
        print("    The guess is based on the Pade (--guess=pade) or Fourier (--guess=ft, default) spectrum")
        print("    with the given <pade opt> or <ft opt> (if the latter were not computed previously).")
        print("")
        print("    <gen-opt>         General options")
        print("    --guess=<guess>   Guess is based on the FT (<guess>=ft, default) or Pade (<guess>=pade) spectrum. If you use either, you can use the corresponding options of the 'ft' or 'pade' command, respectively.")
        print("    --thres=<thres>   If <guess>=pade: Real number in ]0,1] that determines how large a line in the Pade spectrum needs to be relative to the largest lines in order to be considered as for the initial guess. (default: 0.05, i.e., lines with a height of at least 5% of the largest one are considered)")
        print("                      Smaller <smooth> values (=decay rates) result in sharper lines (but still smooth in contrast to the Fourier spectrum). Too small values, however, can produce artifacts. (default: ln(100)/<propagation time>)")
        print("    --nsig=<nsig>     For the current iteration, determines the threshold for adding new lines in the following way: (default: 2.0)")
        print("                      The code takes the residue spectrum, which is essentially the Fourier spectrum minus the fit spectrum, which shows several peaks from the sine-cardinal shaped spectral lines.")
        print("                      In order to distinguish main peaks from side peaks, the code finds all peak in the given spectral range and computes the mean peak height (hbar) and the peak-height standard deviation (hsig).")
        print("                      Peaks that exceed hbar+<nsig>*hsig are accepted as new lines.")
        print("    --range=<lb,rb>   Determines the considered frequency range (in Ry) (default: 0.0,0.4 )")
        print("                      Attention: This option is written into eval.yaml and remembered for future runs.")
        print("    --imag            Only consider imaginary part. (default: true for boost, false else)")
        print("                      Attention: This option is written into eval.yaml and remembered for future runs. To undo it, set the 'imagonly' entry in eval.yaml to 'false' again.")
        print("")
        print("  Note: The guess is automatically computed if you use the 'fit' command.")
        print("        The 'guess' command is useful, if you only want a guess without fitting.")
    if cmd in ["all","rm"]:
        print("")
        print(" ----------")
        print(" Remove excitation without fit")
        print("")
        print("  ./BTevalSpec.py [<gen-opt>] rm <exlist>")
        print("")
        print("    Remove <exlist> from the list of excitations, where exlist is a comma-separated list of excitation labels, e.g., S1,S2,S3")
        print("    Alternatively, you can also remove the excitation manually from eval.yaml.")
    if cmd in ["all","add"]:
        print("")
        print(" ----------")
        print(" Add excitation without fitting")
        print("")
        print("  ./BTevalSpec.py [<gen-opt>] [--nsig=<nsig> | --nex=<nex> | --energy=<en>] [--nofix] add")
        print("")
        print("    Add new excitations either at given energies (optional) or automatically using a sigma-threshold without fitting")
        print("    Before adding new excitations, the existing ones are fixed. Switch that off with the --nofix option.")
        print("")
        print("    <gen-opt>         General options")
        print("    --nsig=<nsig>     For the current iteration, determines the threshold for adding new lines in the following way: (default: 2.0)")
        print("                      The code takes the residue spectrum, which is essentially the Fourier spectrum minus the fit spectrum, which shows several peaks from the sine-cardinal shaped spectral lines.")
        print("                      In order to distinguish main peaks from side peaks, the code finds all peak in the given spectral range and computes the mean peak height (hbar) and the peak-height standard deviation (hsig).")
        print("                      Peaks that exceed hbar+<nsig>*hsig are accepted as new lines.")
        print("    --nex=<nex>       Add <nex> of the next largest excitations (default: 0, i.e., disabled)")
        print("    --energy=<en>     Add excitations at the given energies (as comma-separated list, e.g., <en>=0.160,0.171). Initial values for line heights are extracted from the spectrum (default: "", i.e., disabled)")
        print("    --nofix           Old lines are automatically fixed (i.e., they gain a 'fix=True' in eval.yaml and are not fitted until released). The --nofix flag suppresses this behaviour.")
        print("    --range=<lb,rb>   Determines the considered frequency range (in Ry) (default: 0.0,0.4 )")
        print("                      Attention: This option is written into eval.yaml and remembered for future runs.")
        print("    --imag            Only consider imaginary part (default: true for boost, false else)")
        print("                      Attention: This option is written into eval.yaml and remembered for future runs. To undo it, set the 'imagonly' entry in eval.yaml to 'false' again.")
        print("    --wref=<wref>     Reference-omega for error suppression - suppresses the line-shape error of already fitted lines (that produce spurious lines in the residue spectrum) when searching for new lines.")
        print("                      Usually: small error suppression for <wref>=0.01, large suppression for <wref>=1.0. (default: 0.0)")
    if cmd in ["all","reset"]:
        print("")
        print(" ----------")
        print(" Reset energy range to the standard pi/T interval around the current excitations' energy values")
        print("")
        print("  ./BTevalSpec.py [<gen-opt>] reset")
        print("")
        print("    <gen-opt>         General options")
        print("    When an excitation is added by the code, its energy parameter during the fit is restricted to a symmetric interval around the initial energy value to stabilize the fit.")
        print("    If you note that the rng significance of an excitation is not close to 1, you can try to reset the energy ranges once and, thus, give more freedom to the energy fit.")
    if cmd in ["all","fit"]:
        print("")
        print(" ----------")
        print(" Fit")
        print("")
        print("  ./BTevalSpec.py [<gen-opt>] [<ft opt>] [<guess opt>] [--reset] [--skip] [--single] [--signif] [--range=<lb,rb>] [--crit=<convcrit> | --nadd=<nadd>] [--nsig=<nsig>] [--niter=<niter>] [--imag] [--wref=<wref>] [--fitphase] fit")
        print("")
        print("    Fit excitations following this scheme:")
        print("      1) Fit the present (from eval.yaml) excitations (use --skip to skip this step)")
        print("      2) Fix the present (old) excitations")
        print("      3) Add one batch of new excitations. How many excitations are added in one iteration is controlled by the --nsig (and/or the --nadd) parameter)")
        print("      4) Fit new excitations together (or singly if --single option is given)")
        print("      5) Release the old excitations")
        print("      6) Fit all excitations together")
        print("      7) Go to 2) until --niter iterations are done or --nadd excitations were added or the comprehensive error falls below the convergence criterion <convcrit>")
        print("      8) Compute significances (if --signif is given, also the computationally demanding ones are computed)")
        print("")
        print("    <gen-opt>         General options")
        print("    <ft-opt>          'ft' command options, if ft is was not done before")
        print("    <guess-opt>       'guess' command options, if no lines are present yet")
        print("    --skip            Skip the first collective fit of existing excitations (useful if eval.yaml was changed manually)")
        print("    --nadd=<nadd>     Add up to <nadd> excitations (default: 0)")
        print("    --single          Instead of fitting all excitations at once, fit them one after the other from high to low strength ")
        print("                      Does a prior Fourier transform if not already done.")
        print("                      Does a prior Guess if not already done; requires a range option.")
        print("    --signif          Compute the significance-values that require fitting (costly)")
        print("    --fitphase        Use phase as fit parameter")
        print("                      Attention: This option is written into eval.yaml and remembered for future runs. To undo it, set the 'fitphase' entry in eval.yaml to 'false' again.")
        print("    --crit=<convcrit> Convergence criterion (only relevant if nadd==0 or not present): Add excitations until the fit error drops below this criterion. (default: 0., i.e., disabled)")
        print("    --niter           Maximum number of add-excitation iterations (in each iteration, the number of added excitations is determined by the <nsig> threshold)")
        print("    --reset           Reset energy range (cf. 'reset' command)")
        print("    --nsig=<nsig>     For the current iteration, determines the threshold for adding new lines in the following way: (default: 2.0)")
        print("                      The code takes the residue spectrum, which is essentially the Fourier spectrum minus the fit spectrum, which shows several peaks from the sine-cardinal shaped spectral lines.")
        print("                      In order to distinguish main peaks from side peaks, the code finds all peak in the given spectral range and computes the mean peak height (hbar) and the peak-height standard deviation (hsig).")
        print("                      Peaks that exceed hbar+<nsig>*hsig are accepted as new lines.")
        print("    --range=<lb,rb>   Determines the considered frequency range (in Ry) (default: 0.0,0.4 )")
        print("                      Attention: This option is written into eval.yaml and remembered for future runs.")
        print("    --imag            Only consider imaginary part (default: true for boost, false else)")
        print("                      Attention: This option is written into eval.yaml and remembered for future runs. To undo it, set the 'imagonly' entry in eval.yaml to 'false' again.")
        print("    --wref=<wref>     Reference-omega for error suppression - suppresses the line-shape error of already fitted lines (that produce spurious lines in the residue spectrum) when searching for new lines.")
        print("                      Usually: small error suppression for <wref>=0.01, large suppression for <wref>=1.0. (default: 0.0)")
        print("")
        print("  Note: The simplest approach to fit a spectrum is to do")
        print("        1) one iteration at a time using")
        print("           ./BTevalSpec.py --skip [--nsig=<nsig>] --niter=1 fit")
        print("        2) then evaluate the added excitations (e.g. by inspecting the significance measures)")
        print("        3) backup the resulting eval.yaml")
        print("        4) go to 1) (use --skip to suppress the initial fitting of the input excitations, use the --nsig option to change the threshold for adding new excitation)")
        print("")
        print(" Note: If any significance measure is not close to 1, this can (!) indicate that an excitation is erroneous. Try to remove the the excitation using")
        print("           ./BTevalSpec.py rm <excitation identifier>")
        print("       and call")
        print("           ./BTevalSpec.py fit")
        print("       to just fit the remaining excitations again")
        print("       If the rng significance of an excitation is not close to 1, resetting the energy range using --reset gives the fitting more freedom, which helps sometimes.")
        print("")
        print(" Note: At the end of this command, the script prints what it would do next (i.e., which excitations it would add next).")
        print("       Don't be confused, it looks as if the script had actually done another fit iteration, however, it is just an information.")
        print("")
        print(" Note: Several output files are generated that, e.g., contain the spectra, the fit, the fit-objective function (=kind of f-resolved fit error), a table of excitations, etc.")
        print("       Also, during the fit, the scripts opens a window with the current fit-objective and nsig threshold before fitting in each iteration to show what is actually done.")
        print("       ")
    if cmd in ["all","plot"]:
        print("")
        print(" ----------")
        print(" Plot")
        print("")
        print("  ./BTevalSpec.py [<gen-opt>] [--range=<lb,rb>] [--imag] [--wref=<wref>] [--exclude=<excit>] plot <listOfMeasures>")
        print("")
        print("    Plots <listOfMeasure> in {pade, ft, fit, err, spectrum} with excitations.")
        print("")
        print("    <gen-opt>         General options")
        print("    <listOfMeasures>  [not supported yet] Measures to plot")
        print("    --exclude=<excit> [not supported yet] Comma-separated list of excitations that are excluded from the (fitted) data (default: '' )")
        print("    --range=<lb,rb>   Determines the considered frequency range (in Ry) (default: 0.0,0.4 )")
        print("                      Attention: This option is written into eval.yaml and remembered for future runs.")
        print("    --imag            Only consider imaginary part (default: true for boost, false else)")
        print("                      Attention: This option is written into eval.yaml and remembered for future runs. To undo it, set the 'imagonly' entry in eval.yaml to 'false' again.")
        print("    --wref=<wref>     Reference-omega for error suppression - suppresses the line-shape error of already fitted lines (that produce spurious lines in the residue spectrum) when searching for new lines.")
        print("                      Usually: small error suppression for <wref>=0.01, large suppression for <wref>=1.0. (default: 0.0)")
    if cmd in ["all","fix"]:
        print("")
        print(" ----------")
        print(" Fix")
        print("")
        print("  ./BTevalSpec.py [<gen-opt>] [--invert] fix {<listOfExcitations>|all}")
        print("")
        print("    Fix the given list of excitations (by name). Those remain but are excluded from the fit (i.e., parameters are fixed).")
        print("    If you call with 'all' instead of a list of excitations, all excitations are fixed")
        print("")
        print("    <gen-opt>         General options")
        print("    --invert: Do the same but inverted")
        print("    You can do this manually in eval.yaml as well by setting the 'fix=True' for the respective excitations.")
    if cmd in ["all","release"]:
        print("")
        print(" ----------")
        print(" Release")
        print("")
        print("  ./BTevalSpec.py [<gen-opt>] [--invert] release {<listOfExcitations>|all}")
        print("")
        print("    Release (un-fix) the given list of excitations (by name), cf. 'fix' command")
        print("    If you call with 'all' instead of a list of excitations, all excitations are released")
        print("    You can do this manually in eval.yaml as well by setting the 'fix=False' for the respective excitations.")
    if cmd in ["all","decouple"]:
        print("")
        print(" ----------")
        print(" Decouple")
        print("")
        print("  ./BTevalSpec.py [<gen-opt>] [--jcalc=<calc-idx>] decouple")
        print("")
        print("  Decouple given Fourier-transformed densities n(r,omega) at given omega to get the proper transition densities n_j.")
        print("  Requires Fourier-transform of the density at as many energies as there are excitations (ideally the excitation energies themselves) and a calculation identifier (calculation index).")
        print("  jcalc determines the calculations index from which the density stems (default: 0).")
        print("")
        print("DENSFT:                             # Specify Fourier-transformed densities n(r,w_k) and w_k for transition-density calculation")
        print("  densft:                           #   List of n(r,w_k) (as many as excitations at w_k close to the excitation energies)")
        print("  - densft01.compact                #     Either as complex-valued BTcompact files (requires BTDFT-modules)")
        print("  - densft02.compact")
        print("  #OR")
        print("  - [densft01r.cube,densft01i.cube] #     or lists of [real,imag] Gaussian cube files")
        print("  - [densft02r.cube,densft02i.cube]")
        print("  #OR")
        print("  - densft01i.cube                  #     or imag-valued Gaussian cube files with the --imag to the decouple command option")
        print("  - densft02i.cube")
        print("  #...")
        print("  densen:                           #   the list of w_k (same order)")
        print("  - 0.131990")
        print("  - 0.134330")
        print("  #...")
        print("  jcalc: 0")
        print("")
        print("  After the decoupling, you can the following output with one lines per excitation:")
        print("")
        print("Transition density | abs. norm | real norm | imag norm | sin^2(dAng) | dAbs")
        print("S1                      0.0259     99.92 %      0.08 %      0.00        0.90 %")
        print("...")
        print("")
        print("- Col 1) Excitation name")
        print("- Col 2) int |n_j| d^3r")
        print("- Col 3) Real-valued fraction (must be close to 100%)")
        print("- Col 4) Imag-valued fraction (must be close to   0%)")
        print("- Col 5) Compares the angle between the transition dipole from the fit and the one evaluated from the transition density (must be close to 0)")
        print("- Col 6) Compares the modulus of the transition dipole from the fit and the one evaluated from the transition density (must be close to 0)")
        print("")
        print("If any of the columns 4-6 shows unrealistic values (significantly different from 0), something went wrong.")
